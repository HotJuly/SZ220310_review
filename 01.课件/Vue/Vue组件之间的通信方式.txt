1.props
	使用场景:父向子,子向父

	父向子
		1.父组件给子组件的标签上添加标签属性
			例如 :msg="msg"

		2.子组件在配置对象中,添加props配置项,用于接收对应的标签属性

		小总结:父给子传递的是数据
	子向父
		1.父组件给子组件的标签上添加标签属性
			属性值应该是一个函数
		2.子组件在配置对象中,添加props配置项,用于接收对应的标签属性
		3.子组件调用父组件传下来的函数,并向函数内部传入实参

		注意:
			传递的函数,必须声明在父组件的methods中
				因为声明在methods中的函数,this一定是当前组件的实例对象
					函数声明在谁的methods中,他的this就一定是谁

		问题:为什么methods中的方法的this一定是当前组件的实例对象
		原因:因为methods中的方法,都会被Vue使用bind方法,强行指定this指向

		小总结:父给子传递的是函数


2.provide/inject
	使用场景:祖先组件向后代组件传参
	流程:
		1.祖先组件在自己的配置对象中,添加provide属性,属性值可以是对象或者函数
		2.后代组件在自己的配置对象中,添加inject属性,属性值可以是数组
		

	注意:
		1.默认情况下,provide暴露出去的数据,并不是响应式的
		2.通过函数形式的provide配合Vue.observable方法,可以实现响应式的效果
		3.如果项目中存在多个provide,那么inject接收的数据,就会从父组件开始逐层想上查找

3.自定义事件
	自定义事件和原生事件的区别
		语法:
			1.如果给template中的原生html标签,用@绑定事件,那么该事件就是原生DOM事件
			2.如果给template中的Vue组件标签,用@绑定事件,那么该事件就是自定义事件

		触发:
			原生事件的触发由浏览器负责,自定义事件的触发,需要在Vue中调用$emit方法才能触发

	基础语法:
		1.$on
			用于给某个组件实例绑定自定义事件

		2.$once
			用于给某个组件实例绑定自定义事件,但是只能触发一次

		3.$off
			用于给某个组件实例解绑自定义事件

		4.$emit
			用于触发某个组件实力上的自定义事件

	v-model(双向数据绑定)
		对input标签使用
			1.将data中的数据作为input框的默认值进行展示(属性名为value)
    			<input type="text" :value="username">

			2.当用户修改input框的内容时,会同步修改data中对应的状态数据(事件名为input)
   			<input type="text" :value="username" @input="(event)=>username=event.target.value"/>

		对组件标签使用
			1.将data中的数据作为组件标签的标签属性向下传递(属性名默认为value)
    				<HelloWorld :value="username"/>
				其实就是通过标签属性实现父向子传参

			2.给组件标签绑定自定义事件,子组件可以触发该自定义事件来修改父组件的数据(事件名默认为input)
				<HelloWorld :value="username" @input="(data)=>username=data" />
				其实就是通过自定义事件实现子向父传参

			注意:通过model配置项可以修改绑定的标签属性和自定义事件名称


	.sync修饰符
		无论是否添加.sync修饰符,他对原先的代码都不会产生影响

		1.将data中的数据作为组件标签的标签属性向下传递(属性名可以为任意)
    			<HelloWorld :username="username" />

		2.给组件标签绑定自定义事件,子组件可以触发该自定义事件来修改父组件的数据(事件名为"update:"+属性名)
    			<HelloWorld :username="username" @update:username="(data)=>username=data"/>

			子组件通过触发update:属性名 自定义事件,来修改父组件的数据

	全局事件总线
		角色:
			1.订阅者
			2.发布者

		操作:
			1.订阅
			2.发布
			3.解绑

		约束:
			1.订阅者和发布者必须同时存在
			2.订阅操作必须在发布之前

		流程:
			1.在main.js中,给Vue的原型对象添加全局事件总线对象$bus
				Vue.prototype.$bus = new Vue();

			2.需要接收数据的组件订阅消息
				this.$bus.$on("事件名称",回调函数);

			3.需要发布数据的组件发布数据
				this.$bus.$emit("事件名称",发送的数据)
		
		注意:当组件卸载的时候,一定要解绑当前组件绑定的全局事件



4.找到对应组件的实例对象
	$parent->可以找到当前组件的父组件实例对象
		得到的实例对象其实就是父组件中的this

	$root->可以找到当前项目中的根组件实例对象
		根组件指的是main.js中new Vue创建的实例对象

	$children->可以获得所有子组件实例对象组成的数组
		注意:
			1.如果子组件存在异步组件,那么该数组的顺序可能会与template中的排列顺序不相同
			2.数组不是响应式的,即便将数组中组件的排列顺序进行修改,页面上的显示顺序也不会发生变化

	$refs->可以配合ref标签属性获取到对应标签的内容
		如果对原生标签使用ref
			$refs得到的就是对应标签的原生DOM对象

		如果对组件标签使用ref
			$refs得到的就是组件标签的组件实例对象,也就是组件内部的this

5.$attrs,$listeners
	$attrs->会存储没有被props接收的标签属性
		数据类型:对象
		$attrs其实就是一个垃圾桶,他会props不要的东西


		配合语法:v-bind="对象",那么Vue会将对象中所有的属性名作为标签属性名,属性值作为标签属性值进行使用

	$listeners->会存储当前组件所有的自定义事件
		数据类型:对象


		配合语法:v-on="对象",那么Vue会将对象中所有的属性名作为事件名,属性值作为回调函数使用
	

6.插槽
	插槽传递的是结构
	插槽一共分为三种
	
		默认插槽
			1.向子组件的成对标签中,传入一段插槽结构
			2.子组件中,使用slot组件,来确定这段插槽结构的显示位置

			效果:父向子传参,不过传的是一段页面结构

		具名插槽
			1.向子组件的成对标签中,传入一段插槽结构
				使用v-slot:名称给当前插槽取名

			2.子组件中,使用slot组件,来确定这段插槽结构的显示位置
				给slot组件添加标签属性name,来告知需要显示的是哪个插槽

			默认插槽其实也有名字,就是default

		作用域插槽
			1.向子组件的成对标签中,传入一段插槽结构
				使用v-slot:名称给当前插槽取名

			2.子组件中,使用slot组件,来确定这段插槽结构的显示位置
				给slot组件添加标签属性name,来告知需要显示的是哪个插槽

			3.子组件在书写slot组件的时候,可以通过标签属性给slot组件传参

			4.父组件插槽中,可以通过v-slot="scope"写法,来声明变量接收子组件slot标签上的数据
				最终在插槽中,使用该变量展示数据

			表面上看起来,是子组件向父组件传递了数据
				但是其实,作用域插槽是父向子传参,不存在子向父传参













