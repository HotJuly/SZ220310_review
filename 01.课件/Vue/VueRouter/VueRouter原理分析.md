# VueRouter原理分析

1. 你对VueRouter的了解
   1. 他是Vue的扩展插件库(可以使用Vue.use)
   2. 功能:可以实现单页面项目(SPA)
   3. 问题:什么是单页面应用?
      1. 页面其实就html文件
      2. 单页面应用的意思就是整个项目中只有一个html文件
      3. 单页面应用其实就是通过原生DOM的CRUD方法,对页面上的内容进行操作,实现不能内容的显示效果
   4. 问题:Vue项目中,必须使用VueRouter才能实现单页面应用吗?
      1. 其实只要使用v-if或者v-show,或者component动态组件都能实现单页面应用
      2. 也就是说,VueRouter不是一个必须使用的库
   5. 问题:请问我们有没有做过多页面应用?
      1. 做过的,大疆就是
   6. 使用VueRouter注意点:
      1. 由于当前的Vue最新版本是3.0,所以npm下载包默认是下载4.0版本的VueRouter,而给Vue2项目使用的是3.0版本的VueRouter,下载的时候需要npm i vue-router@3
2. VueRouter提供给我们的东西
   1. 构造函数
      1. 通过VueRouter构造函数,可以创建路由器对象
   2. 全局组件
      1. router-view
         1. 该组件相当于是一个占位符,它可以显示对应的路由组件
         2. **原理:它内部其实使用到了响应式原理,当路由地址发生变化,页面会展示最新的路由组件**
      2. router-link
         1. 会在页面上生成一个a标签,用于引导用户
         2. **声明式导航的定义:通过标签的形式引导用户进行跳转,该类操作称为声明式导航**
         3. **原理:默认生成一个a标签,Vue会禁用a标签的默认行为,并使用编程式导航跳转路由**
   3. 公共对象
      1. $router
         1. 这是路由器对象
         2. 它主要提供一些操作当前路由记录的API,例如:
            1. push
               1. 用处:用于控制路由的跳转,跳转到指定路由
               2. 区别:当前方法会将历史记录保存下来,也就是说绘按钮可以回到上一个路由地址
               3. **编程式导航的定义:通过js的API控制用户的跳转,该类操作称为编程式导航**
               4. **原理:**
                  1. **hash模式下**
                     1. **使用window.location.assign方法,传入需要跳转的hash地址,即可跳转**
                        1. **语法:window.location.assign('/#/home')**
                        2. **会操作当前浏览器的历史记录栈,保留上一个记录,并存储当前记录**
                  2. **history模式下**
                     1. **使用window.history.pushState方法,传入需要跳转的路由地址,即可跳转**
                        1. **语法:window.history.pushState({},'','/about')**
                        2. **会操作当前浏览器的历史记录栈,保留上一个记录,并存储当前记录**
            2. replace
               1. 用处:用于控制路由的跳转,跳转到指定路由
               2. 区别:当前方法会覆盖上次的历史记录,也就是说回退按钮无法回到上一个路由地址了**
               3. **原理:**
                  1. **hash模式下**
                     1. **使用window.location.replace方法,传入需要跳转的hash地址,即可跳转**
                        1. **语法:window.location.replace('/#/home')**
                        2. **会操作当前浏览器的历史记录栈,会覆盖上一个记录**
                  2. **history模式下**
                     1. **使用window.history.replaceState方法,传入需要跳转的路由地址,即可跳转**
                        1. **语法:window.history.replaceState({},'','/about')**
                        2. **会操作当前浏览器的历史记录栈,会覆盖上一个记录**
            3. go
               1. 该方法可以接收一个数字,整数代表前进几层,负数代表后退几层
            4. back
               1. 该方法用户返回上一个路由地址
      2. $route
         1. 这是路由对象
         2. 他主要提供一些与当前所在路由相关的信息,例如:
            1. fullpath->当前路由的完整路径
            2. query->用于存储路由传参的query参数
               1. 格式:/home?a=b&c=d
            3. params->用于存储路由传参的params参数
               1. 格式:/home/1
               2. 注意点:必须在声明路由对象的时候,提前写好占位符
                  1. path:"/home/:id"
            4. meta->用于存储路由的meta参数
               1. 在注册路由的时候,可以给路由对象添加meta属性,属性值是一个对象,内部存放数据
3. 我们需要提供给VueRouter的东西
   1. 配置对象
      1. mode属性
         1. 用于选择当前路由版本
         2. hash
            1. 路径中存在/#/效果
            2. **原理:通过给window对象绑定hashchange事件,可以监视到地址栏中hash值的变化**
            3. 优点:
               1. 兼容性较好,支持IE6+
               2. hash模式下,无论在任何路由地址下刷新页面,都是请求服务器的/路径,前端路由不会发送给服务器,不存在误解析的情况
            4. 缺点:
               1. 长得太丑了,路径中有#不好看
               2. 使用hash模式会影响到锚点功能的正常使用
         3. history
            1. 路径中存在/效果
            2. **原理:通过给window对象绑定popstate事件,可以监视到地址栏中的路径变化**
            3. 优点:
               1. 颜值就是正义,路径中没有/#/,比较好看
               2. 不会影响到锚点功能的使用
            4. 缺点:
               1. 兼容性较差,支持IE10+
               2. 服务器需要做特殊配置
                  1. 问题:
                     1. 如果用户当前正处于某个路由地址下,用户刷新当前页面
                     2. 那么浏览器会将地址栏中的history路由,误识别为后端路由,请求服务器对应的路由接口
                     3. 服务器上并没有该路由接口,那么服务器就会返回404
                  2. 解决方法:
                     1. 如果用户当前正处于某个路由地址下,用户刷新当前页面
                     2. 那么浏览器会将地址栏中的history路由,误识别为后端路由,请求服务器对应的路由接口
                     3. **服务器将自己没有的接口,统一返回index.html文件(我们项目中的html文件)**
                     4. 浏览器接收到服务器返回的html文件,js代码开始执行
                     5. 内部的VueRouter代码会自动获取当前地址栏中的地址,将地址中的路由当作前端路由解析
                     6. VueRouter找到了对应的路由信息,让router-view组件自动显示对应的路由组件
      2. routes属性
         1. 数据类型:routeObj[]
         2. routeObj中重要属性
            1. path
               1. 代表当前路由的路径
            2. component
               1. 如果当前地址栏中路径与path相同,那么就显示当前对应的component
4. 导航守卫
   1. 一共有几大类的导航守卫
      1. 分为三大类
      2. 全局守卫
         1. 全局前置守卫
            1. API:beforeEach 
            2. 从某个路由出发跳转操作,还没有出发之前
            3. 简单点说,就是出发之前检查
         2. 全局解析守卫
            1. API:beforeResolve
            2. 所有组件内守卫和异步路由组件被解析之后
         3. 全局后置守卫
            1. API:afterEach
            2. 到达了想要跳转的路由之后触发
            3. 简单点说,就是到达之后检查
      3. 路由独享守卫
         1. API:beforeEnter
         2. 即将进入当前路由的时候触发
      4. 组件内置守卫
         1. 组件前置守卫
            1. API:beforeRouteEnter
            2. 即将进入当前组件的时候触发
         2. 组件更新守卫
            1. API:beforeRouteUpdate
            2. 当前组件被复用展示时候触发
            3. 可以监视跳转之后是否还是同一个组件,如果还是同一个组件那么就执行当前守卫
         3. 组件离开守卫
            1. API:beforeRouteLeave
            2. 即将离开当前组件的时候触发