# VueRouter原理分析

1. VueRouter的作用

   1. 他是Vue的扩展插件库
   2. 用于实现单页面应用(SPA)
   3. 问题:什么是单页面应用?
      1. 页面指的就是html
      2. 而单页面应用,说的就是整个项目只有一个html文件,只不过页面上内容的变化,全都是靠DOM的CRUD方法操作实现的
   4. 问题:如果不是用VueRouter,只用Vue能实现单页面应用吗?
      1. 可以,因为Vue自己也有切换页面显示内容的能力,例如:动态组件,v-if,v-show等
   5. 注意:
      1. 目前直接使用npm i vue-router默认下载的是4.0版本的VueRouter,是专门给Vue3使用的,如果是想给Vue2项目使用,需要npm i vue-router@3

2. VueRouter给我们提供了什么?

   1. 构造函数

      1. 用于创建路由器对象,管理路由

   2. 全局组件

      1. router-view
         1. 用处:当url中的路径与某个路由对象中的path匹配,那么该组件就显示对应的路由组件
         2. 相当于是占位符,类似于slot组件
         3. **需求:当路径发生变化时,router-view显示最新的路由组件**
            1. **原理:其实router-view中使用了响应式原理**
      2. router-link
         1. 用处:在页面上默认显示一个a标签,当用户点击a标签,就跳转到指定的路由地址
         2. **定义:在页面上通过标签的形式,引导用户进行跳转的方法,我们成为声明式导航**
         3. **原理:其实router-link组件中,就是生成了一个a标签,并且禁用该a标签的默认行为,同时还会给a标签绑定点击事件,在回调函数中使用编程式导航**

   3. 公共对象

      1. $router

         1. 用于提供操作/管理当前所有路由的方法(API)
         2. 提供的API
            1. **定义:使用js的API,强行控制用户跳转的方法,我们称为编程式导航**
            2. push
               1. 可以控制当前路由地址的跳转,并保留当前的路由记录,跳转到下个路由
               2. 也就是说使用该方法跳转的路由,还可以返回到当前路由
               3. **原理:**
                  1. **hash模式下,会使用window.location.assign('/#/about')控制地址栏中的路径跳转,同时会操作浏览器的历史记录栈,会将当前记录推入历史记录栈中**
                  2. **history模式下,会使用window.history.pushState('/about')控制地址栏中的路径跳转,同时会操作浏览器的历史记录栈,会将当前记录推入历史记录栈中**
            3. replace
               1. 可以控制当前路由地址的跳转,但是不会保留当前的路由记录,会将当前路由的历史记录覆盖,跳转到下个路由
               2. 也就是说使用该方法跳转的路由,无法返回当前路由
               3. **原理:**
                  1. **hash模式下,会使用window.location.replace('/#/about')控制地址栏中的路径跳转,同时会操作浏览器的历史记录栈,覆盖上一个记录**
                  2. **history模式下,会使用window.history.replaceState({},"",'/about')控制地址栏中的路径跳转,同时会操作浏览器的历史记录栈,覆盖上一个记录**
            4. go
               1. 可以传入一个数字,如果是整数就前进几层,如果是负数就后退几层
            5. back
               1. 可以直接回退到上一个路由

      2. $route

         1. 用于提供与当前路由相关的信息

         2. 提供的数据

            1. fullPath和path属性

               1. 用于提供当前路由的路径

            2. query

               1. query传参属于URL传参
               2. 用于接收路由跳转时候传递的query参数
               3. 语法:"/about?username=xiaoming"

            3. params

               1. params传参属于URL传参


               1. 用于接收路由跳转时候传递的params参数
               2. 语法:"/about/1"
               3. 注意
                  1. 需要在声明路由路径的时候,在路径中写好占位符,例如:"/about/:id"

            4. meta

               1. 用于接收声明路由对象时候传入的meta参数

3. 我们需要给VueRouter提供什么?

   1. 配置对象
      1. mode属性
         1. 该属性用于声明当前使用的路由模式
         2. 属性值是字符串
         3. 属性值
            1. hash
               1. 地址栏路径中带有/#
               2. 其实用的就是原生的hash对象模式
               3. **原理:hash模式下,可以通过给window绑定hashchange事件,监视路径中的hash值变化,并执行对应的回调函数**
               4. **优点:**
                  1. **hash模式的兼容性好,可以兼容到IE6**
                  2. **上线hash模式的代码,不需要做任何配置**
               5. **缺点:**
                  1. **长得太丑,有罪,路径中带有/#**
                  2. **在浏览器中,hash值和锚点功能会互相影响,导致锚点无法使用**
            2. history
               1. 地址栏路径中带有/
               2. 其实用的就是HTML5新增的history对象模式
               3. **原理:history模式下,可以通过给window绑定popstate事件,监视地址中的路径变化,并执行对应的回调函数**
               4. **优点:**
                  1. **颜值就是正义,路径好看**
                  2. **锚点功能可以正常使用**
               5. **缺点:**
                  1. **history模式的兼容性差,可以兼容到IE10+**
                  2. **想要上线history模式的代码,需要服务器进行特殊配置**
               6. **问题:**
                  1. **如果在history模式的某个路由地址下刷新,此时浏览器会将前端路由,误识别为后端路由发送给服务器,请求该接口,但是服务器又没有该接口,那么就返回404**
               7. **如何处理该问题?(也就是上线之前,服务器需要做的配置)**
                  1. **让服务器自己没有的接口,统一返回index.html文件**
      2. routes属性
         1. 该属性用于声明当前项目中所有可用的路由信息
         2. 属性值是 路由对象[]
         3. 路由对象的重要属性
            1. path属性
               1. 声明当前路由的路径
            2. component属性
               1. 声明当前路由的组件信息

4. 导航守卫

   1. 导航守卫一共有7个
   2. 他们就相当于是全新的生命周期
   3. 通过导航守卫可以控制项目路由的跳转,任何一个环节没有放行,当前跳转都会失败
   4. 全局守卫
      1. 全局前置守卫
         1. 当路由跳转开始之前,执行自己的回调函数
      2. 全局解析守卫
         1. 当路由组件解析结束之后,执行自己的回调函数
      3. 全局后置守卫
         1. 当路由跳转结束之后,执行自己的回调函数
   5. 路由独享守卫
      1. 当准备跳转某个指定路由时,执行自己的回调函数
   6. 组件守卫
      1. 组件进入守卫
         1. 当准备跳转进入某个路由组件时,执行自己的回调函数
      2. 组件更新守卫
         1. 在当前路由改变,但是该组件被复用时调用,执行自己的回调函数
      3. 组件离开守卫
         1. 当准备跳转离开某个路由组件时,执行自己的回调函数